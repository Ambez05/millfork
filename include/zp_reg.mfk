
#if not(ARCH_6502)
#warn zp_reg module should be used only on 6502-compatible targets
#endif

noinline asm byte __mul_u8u8u8() {
    ? LDA #0
    ? JMP __mul_u8u8u8_start
__mul_u8u8u8_add:
    ? CLC
    ? ADC __reg
__mul_u8u8u8_loop:
    ? ASL __reg
__mul_u8u8u8_start:
    ? LSR __reg+1
    ? BCS __mul_u8u8u8_add
    ? BNE __mul_u8u8u8_loop
    ? RTS
}

// divide __reg[0]/__reg[1]

noinline asm byte __mod_u8u8u8u8() {
    ? LDA #0
    ? LDX #7
    ? CLC
__divmod_u8u8u8u8_start:
    ? ROL __reg
    ? ROL
    ? CMP __reg+1
    ? BCC __divmod_u8u8u8u8_skip
    ? SBC __reg+1
__divmod_u8u8u8u8_skip:
    ? DEX
    ? BPL __divmod_u8u8u8u8_start
    ? ROL __reg
    ? RTS
}

asm byte __div_u8u8u8u8() {
    ? JSR __mod_u8u8u8u8
    ? LDA __reg
    ? RTS
}

#if ZPREG_SIZE >= 3

noinline asm word __mul_u16u8u16() {
    ? LDA #0
    ? TAX
    ? JMP __mul_u16u8u16_start
__mul_u16u8u16_add:
    ? CLC
    ? ADC __reg
    ? TAY
    ? TXA
    ? ADC __reg+1
    ? TAX
    ? TYA
__mul_u16u8u16_loop:
    ? ASL __reg
    ? ROL __reg+1
__mul_u16u8u16_start:
    ? LSR __reg+2
    ? BCS __mul_u16u8u16_add
    ? BNE __mul_u16u8u16_loop
    ? RTS
}

// divide (__reg[1]:__reg[0])/__reg[2]

noinline asm byte __mod_u16u8u16u8() {
    ? LDA #0
    ? LDX #15
    ? CLC
__divmod_u16u8u16u8_start:
    ? ROL __reg
    ? ROL __reg+1
    ? ROL
    ? CMP __reg+2
    ? BCC __divmod_u16u8u16u8_skip
    ? SBC __reg+2
__divmod_u16u8u16u8_skip:
    ? DEX
    ? BPL __divmod_u16u8u16u8_start
    ? ROL __reg
    ? ROL __reg+1
    ? RTS
}

asm word __div_u16u8u16u8() {
    ? JSR __mod_u16u8u16u8
    ? LDA __reg
    ? LDX __reg+1
    ? RTS
}

#endif
